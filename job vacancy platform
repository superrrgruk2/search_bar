#include <graphics.h>
#include <conio.h>
#include <fstream>
#include <string>
#include <iostream>
#include <windows.h>
#include <cstring>
#include <vector>
#include <cctype>
#include <algorithm>

using namespace std;

int screenWidth = GetSystemMetrics(SM_CXSCREEN);
int screenHeight = GetSystemMetrics(SM_CYSCREEN);
// File to store jobs
const string JOB_FILE = "jobs.txt";

// Back button coordinates (bottom-right)
const int backBtnX1 = screenWidth - 150;
const int backBtnY1 = screenHeight - 70;
const int backBtnX2 = screenWidth - 50;
const int backBtnY2 = screenHeight - 30;

// Declaring Global Variable
int scrollOffset = 0;
const int SCROLL_STEP = 30;
//mainMenu();

// Global role tracker
string currentRole = "";


// JOB SEARCH DATA
const int JOB_COUNT = 5;
const int MAX_LENGTH = 50;
char jobs[JOB_COUNT][MAX_LENGTH] = {
    
};

void mainMenu();
vector<string> loadJobs();
void  drawBackButton();
bool backButtonClicked(int mx, int my);
// Utility: Draw button
void drawButton(int x, int y, int width, int height, char label[]);

// Utility: Mouse inside check
bool isMouseInside(int x, int y, int width, int height) {
    int mx = mousex();
    int my = mousey();
    return (mx >= x && mx <= x + width && my >= y && my <= y + height);
}


// Utility: Get input
void getInput(char label[], int x, int y, char input[], int maxLen, bool isPassword = false) {
    setcolor(WHITE);
    outtextxy(x, y, label);
    rectangle(x + textwidth(label) + 10, y, x + 400, y + 30);
    int i = 0;
    char ch;
    input[0] = 0;

    while (true) {
        ch = getch();
        if (ch == 13) break;
        else if (ch == 8 && i > 0) {
            i--;
            input[i] = 0;
        } else if (isprint(ch) && i < maxLen - 1) {
            input[i++] = ch;
            input[i] = 0;
        }

        setfillstyle(SOLID_FILL, BLACK);
        bar(x + textwidth(label) + 11, y + 1, x + 399, y + 29);

        if (isPassword) {
            char temp[100];
            for (int j = 0; j < i; ++j) temp[j] = '*';
            temp[i] = 0;
            outtextxy(x + textwidth(label) + 15, y + 5, temp);
        } else {
            outtextxy(x + textwidth(label) + 15, y + 5, input);
        }
    }
}

// JOB SEARCH SCREEN
void background_images() {
     readimagefile("D:\\villian\\prince.bmp", 0, 0, screenWidth, screenHeight);
}

void drawJobSearchScreen(const char input[]) {
    background_images();
    settextstyle(DEFAULT_FONT, HORIZ_DIR, 7);
    setcolor(WHITE);
    setfillstyle(SOLID_FILL, BLACK);
    bar(435, 55, 780, 111);
    outtextxy(40, 50, (char*)"JOB VACANCY PLATFORM");

    // Search box
    setcolor(WHITE);
    rectangle(40, 160, 1200, 200);
    setfillstyle(SOLID_FILL, BLACK);
    bar(41, 161, 999, 199);
    setcolor(WHITE);
    settextstyle(SIMPLEX_FONT, HORIZ_DIR, 2); // Only one settextstyle needed 

    outtextxy(45, 173, (char*)input);
    
    
    
}

void showJobsScreen() {
    while (true) {
        cleardevice();
        background_images();
        setbkcolor(BLACK);
        settextstyle(10, 0, 2);
        setcolor(WHITE);
        outtextxy(50, 30, (char *)"Available Jobs:");
        drawBackButton();

        vector<string> jobs = loadJobs();
        int y = 80 - scrollOffset;
        int boxHeight = 170;
        int boxWidth = 1000;
        int xStart = 50;

        if (jobs.empty()) {
            outtextxy(70, y, (char *)"No jobs available.");
        }
        
 
        for (int i = 0; i < jobs.size(); i++) {
            setcolor(WHITE);
            rectangle(xStart, y, xStart + boxWidth, y + boxHeight);
            setfillstyle(SOLID_FILL, BLACK);
            bar(xStart + 1, y + 1, xStart + boxWidth - 1, y + boxHeight - 1);

            string job = jobs[i];
            vector<string> fields;
            size_t pos = 0;
            while ((pos = job.find(" | ")) != string::npos) {
                fields.push_back(job.substr(0, pos));
                job.erase(0, pos + 3);
            }
            fields.push_back(job);

            int fieldY = y + 15;
            for (string &f : fields) {
                outtextxy(xStart + 20, fieldY, (char *)f.c_str());
                fieldY += 25;
            }

            y += boxHeight + 10;
        }
  while (!ismouseclick(WM_LBUTTONDOWN)) {}
        int mx, my;
        getmouseclick(WM_LBUTTONDOWN, mx, my);
        if (backButtonClicked(mx, my)) return;
      
    }
}


void showResults(const char input[]) {
    cleardevice();
    background_images();
    setbkcolor(BLACK);
    setcolor(WHITE);
    settextstyle(BOLD_FONT, HORIZ_DIR, 3);

    vector<string> allJobs = loadJobs();
    vector<string> matchedJobs;

    // Convert input to lowercase
    char tempInput[MAX_LENGTH];
    strcpy(tempInput, input);
    for (int j = 0; tempInput[j]; j++) tempInput[j] = tolower(tempInput[j]);

    // Find matching jobs
    for (string &job : allJobs) {
        string tempJob = job;
        transform(tempJob.begin(), tempJob.end(), tempJob.begin(), ::tolower);

        if (tempJob.find(tempInput) != string::npos) {
            matchedJobs.push_back(job);
        }
    }

    if (matchedJobs.empty()) {
        setcolor(RED);
        settextstyle(SIMPLEX_FONT, HORIZ_DIR, 3);
        outtextxy((screenWidth - textwidth("No matching jobs found.")) / 2, 200, (char*)"No matching jobs found.");

        // Draw "Back" button
        int buttonW = 200, buttonH = 50;
        int x = (screenWidth - buttonW) / 2;
        int y = 300;
        int mx, my;
getmouseclick(WM_LBUTTONDOWN, mx, my);

        drawButton(x, y, buttonW, buttonH, (char*)"Back");

        while (true) {
        	
            if (ismouseclick(WM_LBUTTONDOWN)) {
               // Scroll up and down with arrow keys
				if (GetAsyncKeyState(VK_UP)) {
    				scrollOffset = max(0, scrollOffset - SCROLL_STEP);
				}
				if (GetAsyncKeyState(VK_DOWN)) {
  				  scrollOffset += SCROLL_STEP;
}
delay(100);

                if (mx >= x && mx <= x + buttonW && my >= y && my <= y + buttonH) {
                    clearmouseclick(WM_LBUTTONDOWN);
                    return;  // Go back to previous screen
                }
            }
        }
    } else {
        setcolor(WHITE);
        settextstyle(10, 0, 2);
        outtextxy(50, 30, (char *)"Available Jobs:");

        int y = 80;
        int boxHeight = 170;
        int boxWidth = 1000;
        int xStart = 50;

        for (const string &job : matchedJobs) {
            setcolor(WHITE);
            rectangle(xStart, y, xStart + boxWidth, y + boxHeight);
            setfillstyle(SOLID_FILL, BLACK);
            bar(xStart + 1, y + 1, xStart + boxWidth - 1, y + boxHeight - 1);

            // Split fields by " | "
            vector<string> fields;
            string jobCopy = job;
            size_t pos = 0;
            while ((pos = jobCopy.find(" | ")) != string::npos) {
                fields.push_back(jobCopy.substr(0, pos));
                jobCopy.erase(0, pos + 3);
            }
            fields.push_back(jobCopy); // last part

            int fieldY = y + 15;
            for (const string &f : fields) {
                outtextxy(xStart + 20, fieldY, (char *)f.c_str());
                fieldY += 25;
            }

            y += boxHeight + 10;
        }
    }
}


void jobSearchScreen() {
    cleardevice();
    background_images();
    char input[MAX_LENGTH] = "";
    int index = 0;
    char ch;

    drawJobSearchScreen(input);

    while (true) {
        ch = getch();
        if (ch == 13) break;
        if (ch == 8 && index > 0) {
            index--;
            input[index] = '\0';
        } else if (ch >= 32 && ch <= 126 && index < MAX_LENGTH - 1) {
            input[index++] = ch;
            input[index] = '\0';
        }

        drawJobSearchScreen(input);
    }

    cleardevice();
    drawJobSearchScreen(input);
    showResults(input);
    getch();
}

// MAIN INTERFACES

void showMainMenu();
void signupForm();
void showLoginSignupMenu(char role[]);

void loginForm() {
    cleardevice();
    background_images();
    setbkcolor(BLACK);
    setcolor(WHITE);
    settextstyle(BOLD_FONT, HORIZ_DIR, 3);
    char title[100];
    sprintf(title, "%s Portal", currentRole.c_str());
    outtextxy((screenWidth - textwidth(title)) / 2, 100, title);

    int buttonW = 400, buttonH = 70;
    int x = (screenWidth - buttonW) / 2;
    int y = 250;

    char uname[100], pass[100];
    settextstyle(BOLD_FONT, HORIZ_DIR, 2);
    outtextxy(300, 160, (char*)"* Username and password are case sensitive");
    getInput((char*)"Username:", 300, 200, uname, 100);
    getInput((char*)"Password:", 300, 250, pass, 100, true);

    const char* filename = (currentRole == "Employer") ? "employers.txt" : "jobseekers.txt";
    ifstream file(filename);
    string u, p;
    bool valid = false;

    while (file >> u >> p) {
        if (u == uname && p == pass) {
            valid = true;
            break;
        }
    }

    if (valid) {
        if (currentRole == "JobSeeker") {
            jobSearchScreen();
        } else {
            cleardevice();
            settextstyle(BOLD_FONT, HORIZ_DIR, 4);
            char msg[100];
            sprintf(msg, "Welcome, %s!", uname);
            outtextxy((screenWidth - textwidth(msg)) / 2, screenHeight / 2, msg);
            delay(2000);
            mainMenu();
        }
    } else {
        drawButton(x + 200, y, buttonW, buttonH, (char*)"Invalid credentials.");
        delay(1000);
        getch();
    }
}

void signupForm() {
    cleardevice();
    background_images();
    setbkcolor(BLACK);
    setcolor(WHITE);
    settextstyle(BOLD_FONT, HORIZ_DIR, 3);
    char title[100];
    sprintf(title, "%s Portal", currentRole.c_str());
    outtextxy((screenWidth - textwidth(title)) / 2, 100, title);

    int buttonW = 400, buttonH = 70;
    int x = (screenWidth - buttonW) / 2;
    int y = 550;

    char uname[100], pass[100];
    char name[100], address[100], phone[100], email[100];
    const char* filename = (currentRole == "Employer") ? "employers.txt" : "jobseekers.txt";

    getInput((char*)"Company Name:", 300, 150, name , 300);
	getInput((char*)"Full Name:", 300, 200, name, 300);
    getInput((char*)"Address:", 300, 250, address, 300);
    getInput((char*)"Phone No:", 300, 300, phone, 300);
    getInput((char*)"Email ID:", 300, 350, email, 300);
    getInput((char*)"Username:", 300, 400, uname, 300);
    getInput((char*)"Password:", 300, 450, pass, 300 , true);

    // Check for empty fields
    if (strlen(name) == 0 || strlen(address) == 0 || strlen(phone) == 0 || 
        strlen(email) == 0 || strlen(uname) == 0 || strlen(pass) == 0) {
        drawButton(x, y, buttonW, buttonH, (char*)"All fields are required!");
        delay(1500);
        getch();
        return;
    }

    // Check if phone number is all digits
    bool isValidPhone = true;
    for (int i = 0; i < strlen(phone); i++) {
        if (!isdigit(phone[i])) {
            isValidPhone = false;
            break;
        }
    }

    if (!isValidPhone) {
        drawButton(x, y, buttonW, buttonH, (char*)"Phone No. must be digits only!");
        delay(1500);
        getch();
        return;
    }

    // Save to file
    ofstream file(filename, ios::app);
    file << uname << " " << pass << endl;

    drawButton(x, y, buttonW, buttonH, (char*)"Sign up successful!");
    delay(1000);
    getch();
}


void showLoginSignupMenu(char role[]) {
    currentRole = role;
    setbkcolor(BLACK);
    cleardevice();
    background_images();
    settextstyle(BOLD_FONT, HORIZ_DIR, 3);
    setcolor(WHITE);
    char heading[100];
    sprintf(heading, "%s Portal", role);
    outtextxy((screenWidth - textwidth(heading)) / 2, 100, heading);

    int buttonW = 400, buttonH = 70;
    int x = (screenWidth - buttonW) / 2;
    int loginY = 250, signupY = 350, backY = 450;

    drawButton(x, loginY, buttonW, buttonH, (char*)"Login");
    drawButton(x, signupY, buttonW, buttonH, (char*)"Sign Up");
    drawButton(x, backY, buttonW, buttonH, (char*)"Back to Main Menu");

    delay(200);

    while (true) {
        if (ismouseclick(WM_LBUTTONDOWN)) {
            clearmouseclick(WM_LBUTTONDOWN);
            if (isMouseInside(x, loginY, buttonW, buttonH)) {
                loginForm();
                showLoginSignupMenu(role);
                return;
            } else if (isMouseInside(x, signupY, buttonW, buttonH)) {
                signupForm();
                showLoginSignupMenu(role);
                return;
            }
            }
        }
    }





// Draw back button
void drawBackButton() {
    setfillstyle(SOLID_FILL, DARKGRAY);
    background_images();  //put this in every page
    bar(backBtnX1, backBtnY1, backBtnX2, backBtnY2);
    setcolor(WHITE);
    rectangle(backBtnX1, backBtnY1, backBtnX2, backBtnY2);
    setbkcolor(BLACK);
    settextstyle(10, 0, 2);
    outtextxy(backBtnX1 + 20, backBtnY1 + 8, (char *)"Back");
}

// Check if back button was clicked
bool backButtonClicked(int mx, int my) {
    return (mx >= backBtnX1 && mx <= backBtnX2 && my >= backBtnY1 && my <= backBtnY2);
}

// Load all jobs
vector<string> loadJobs() {
    vector<string> jobs;
    ifstream infile(JOB_FILE);
    string job;
    while (getline(infile, job)) {
        if (!job.empty())
            jobs.push_back(job);
    }
    infile.close();
    return jobs;
}

string getInputField(int x, int y, const char* label) {
    settextstyle(10, 0, 2);
    setcolor(WHITE);
    outtextxy(x, y, (char*)label);

    int boxX = x + 250, boxY = y, boxW = 400;
    rectangle(boxX, boxY, boxX + boxW, boxY + 30);

    string input = "";
    char ch;
    while (true) {
        if (ismouseclick(WM_LBUTTONDOWN)) {
            int mx, my;
            getmouseclick(WM_LBUTTONDOWN, mx, my);
            if (backButtonClicked(mx, my)) return "BACK";
        }
        ch = getch();
        if (ch == 13) break;
        else if (ch == 8 && !input.empty()) input.pop_back();
        else if (isprint(ch) && input.length() < 50) input += ch;

        setfillstyle(SOLID_FILL, BLACK);
        bar(boxX + 2, boxY + 2, boxX + boxW - 2, boxY + 28);
        setcolor(WHITE);
        outtextxy(boxX + 5, boxY + 5, (char*)input.c_str());
    }
    return input;
}



void postJobStepForm() {
    cleardevice();
    background_images();
    background_images();  //put this in every page
    drawBackButton();
    settextstyle(10, 0, 3);
    setcolor(WHITE);
    outtextxy(50, 30, (char*)"Post New Job - Step by Step");

    int yStart = 100;
    string company = getInputField(50, yStart, "Company Name:");
    if (company == "BACK") return;
    string address = getInputField(50, yStart + 60, "Address:");
    if (address == "BACK") return;
    string role = getInputField(50, yStart + 120, "Role:");
    if (role == "BACK") return;
    string salary = getInputField(50, yStart + 180, "Salary (NRs):");
    if (salary == "BACK") return;
    string age = getInputField(50, yStart + 240, "Age Requirement:");
    if (age == "BACK") return;
    string Experience = getInputField(50, yStart + 300, "Experience:");
    if (Experience == "BACK") return;
    string field = getInputField(50, yStart + 360, "Field:");
    if (field == "BACK") return;

    setfillstyle(SOLID_FILL, GREEN);
    bar(800, 600, 950, 650);
    setcolor(RED);
    rectangle(800, 600, 950, 650);
    outtextxy(830, 615, (char *)"Done");

    int mx, my;
    while (true) {
        if (ismouseclick(WM_LBUTTONDOWN)) {
            getmouseclick(WM_LBUTTONDOWN, mx, my);
            if (mx >= 800 && mx <= 950 && my >= 600 && my <= 650)
                break;
            if (backButtonClicked(mx, my)) return;
        }
    }

    ofstream outfile(JOB_FILE, ios::app);
    outfile << "Company Name : " << company << " | Address: " << address
            << " | Role: " << role << " | Salary: NRs " << salary
            << " | Age: " << age << " | Field: " << field << endl;
    outfile.close();

    cleardevice();
    settextstyle(10, 0, 3);
    outtextxy(100, 200, (char *)"? Job posted successfully!");
    outtextxy(100, 250, (char *)"Press any key to return...");
    getch();
}

void deleteJobScreen() {
    cleardevice();
    background_images();//put this in every page
    drawBackButton();
    setbkcolor(BLACK);
    settextstyle(10, 0, 2);
    setcolor(WHITE);
    outtextxy(50, 30, (char *)"Delete Job - Click 'Delete' next to a job");

    vector<string> jobs = loadJobs();
    if (jobs.empty()) {
        outtextxy(70, 100, (char *)"No jobs to delete.");
        getch();
        return;
    }

    int boxHeight = 170;
    int boxWidth = 1000;
    int xStart = 50;
    int yStart = 80;
    vector<RECT> deleteButtons;

    for (int i = 0; i < jobs.size(); i++) {
        int y = yStart + i * (boxHeight + 10) - scrollOffset;


        setcolor(WHITE);
        rectangle(xStart, y, xStart + boxWidth, y + boxHeight);
        setfillstyle(SOLID_FILL, BLACK);
        bar(xStart + 1, y + 1, xStart + boxWidth - 1, y + boxHeight - 1);

        string job = jobs[i];
        vector<string> fields;
        size_t pos = 0;
        while ((pos = job.find(" | ")) != string::npos) {
            fields.push_back(job.substr(0, pos));
            job.erase(0, pos + 3);
        }
        fields.push_back(job);

        int fieldY = y + 15;
        for (string &f : fields) {
            outtextxy(xStart + 20, fieldY, (char *)f.c_str());
            fieldY += 25;
        }

        int bx = xStart + boxWidth - 120;
        int by = y + boxHeight - 50;
        int bw = 100, bh = 30;
        setfillstyle(SOLID_FILL, RED);
        bar(bx, by, bx + bw, by + bh);
        setcolor(WHITE);
        rectangle(bx, by, bx + bw, by + bh);
        outtextxy(bx + 20, by + 5, (char *)"Delete");

        RECT btn = {bx, by, bx + bw, by + bh};
        deleteButtons.push_back(btn);
    }

    int mx, my;
    while (true) {
    	
    	if (GetAsyncKeyState(VK_UP)) {
    scrollOffset = max(0, scrollOffset - SCROLL_STEP);
}
if (GetAsyncKeyState(VK_DOWN)) {
    scrollOffset += SCROLL_STEP;
}
delay(100);

        if (ismouseclick(WM_LBUTTONDOWN)) {
            getmouseclick(WM_LBUTTONDOWN, mx, my);
            if (backButtonClicked(mx, my)) return;
            for (int i = 0; i < deleteButtons.size(); i++) {
                RECT btn = deleteButtons[i];
                if (mx >= btn.left && mx <= btn.right && my >= btn.top && my <= btn.bottom) {
                    jobs.erase(jobs.begin() + i);
                    ofstream outfile(JOB_FILE);
                    for (string &job : jobs) outfile << job << endl;
                    outfile.close();
                    deleteJobScreen();
                    return;
                }
            }
        }
    }
}

void drawButton(int x, int y, int w, int h, const char *label) {
    setfillstyle(SOLID_FILL, LIGHTGRAY);
    bar(x, y, x + w, y + h);
    setcolor(WHITE);
    rectangle(x, y, x + w, y + h);
    setcolor(BLACK);
    setbkcolor(LIGHTGRAY);
    settextstyle(10, 0, 3);
    outtextxy(x + 30, y + 15, (char *)label);
}

bool isClicked(int x, int y, int w, int h, int mx, int my) {
    return (mx >= x && mx <= x + w && my >= y && my <= y + h);
}

void mainMenu() {
    int mx, my;
    bool running = true;

    while (running) {
        cleardevice();
        background_images();
        settextstyle(10, 0, 5);
        setcolor(WHITE);
        outtextxy(600, 40, (char *)"Employer Portal");

        drawButton(650, 150, 300, 60, "View Jobs");
        drawButton(650, 240, 300, 60, "Post Job");
        drawButton(650, 330, 300, 60, "Delete Job");
        drawButton(650, 420, 300, 60, "Exit");

        while (!ismouseclick(WM_LBUTTONDOWN)) {}
        getmouseclick(WM_LBUTTONDOWN, mx, my);

        if (isClicked(650, 150, 300, 60, mx, my))
            showJobsScreen();
        else if (isClicked(650, 240, 300, 60, mx, my))
            postJobStepForm();
        else if (isClicked(650, 330, 300, 60, mx, my))
            deleteJobScreen();
        else if (isClicked(650, 420, 300, 60, mx, my))
            running = false;
    }
}   

int main() {
    initwindow(screenWidth, screenHeight, "Job Vacancy Platform");
  
    
    const char* line1 = "Welcome to the";
    const char* line2 = "Employer Management System";

    settextstyle(TRIPLEX_FONT, HORIZ_DIR, 7);
    int text1Width = textwidth((char*)line1);
    int text2Width = textwidth((char*)line2);
    int textHeight = textheight((char*)line1);

    int paddingX = 80, paddingY = 60;
    int boxWidth = max(text1Width, text2Width) + 2 * paddingX;
    int boxHeight = 2 * textHeight + 3 * paddingY;
    int boxX = (screenWidth - boxWidth) / 2;
    int boxY = (screenHeight - boxHeight) / 2;

    int finalX1 = (screenWidth - text1Width) / 2;
    int finalX2 = (screenWidth - text2Width) / 2;
    int y1 = boxY + paddingY;
    int y2 = y1 + textHeight + paddingY / 2;

    int startX1 = -text1Width;
    int startX2 = screenWidth;

    int page = 0;

    while (startX1 < finalX1 || startX2 > finalX2) {
        setactivepage(page);     // draw on passive page
        setvisualpage(1 - page); // show previous page

        cleardevice();
        setbkcolor(BLACK);
        setfillstyle(SOLID_FILL, WHITE);
        bar(boxX, boxY, boxX + boxWidth, boxY + boxHeight);

        setcolor(BLACK);
        rectangle(boxX, boxY, boxX + boxWidth, boxY + boxHeight);

        setcolor(BLUE);
        settextstyle(TRIPLEX_FONT, HORIZ_DIR, 7);

        if (startX1 < finalX1) startX1 += 5;
        if (startX2 > finalX2) startX2 -= 5;

        outtextxy(startX1, y1, (char*)line1);
        outtextxy(startX2, y2, (char*)line2);

        delay(20);
        page = 1 - page; // toggle page
    }

    // Final static view (no flickering)
    setactivepage(0);
    setvisualpage(0);
    setbkcolor(BLACK);
    cleardevice();
    setfillstyle(SOLID_FILL, WHITE);
    bar(boxX, boxY, boxX + boxWidth, boxY + boxHeight);
    setcolor(BLACK);
    rectangle(boxX, boxY, boxX + boxWidth, boxY + boxHeight);
    setcolor(BLUE);
    settextstyle(TRIPLEX_FONT, HORIZ_DIR, 7);
    outtextxy(finalX1, y1, (char*)line1);
    outtextxy(finalX2, y2, (char*)line2);
    
    while (true) 
      {
                showLoginSignupMenu((char*)"Employer");
    }
    getch();
    closegraph();
    return 0;
}

void drawButton(int x, int y, int width, int height, char label[]) {
    setcolor(WHITE);
    setfillstyle(SOLID_FILL, DARKGRAY);
    bar(x, y, x + width, y + height);
    rectangle(x, y, x + width, y + height);
    setbkcolor(DARKGRAY);
    settextstyle(BOLD_FONT, HORIZ_DIR, 2);
    outtextxy(x + (width - textwidth(label)) / 2, y + (height - textheight(label)) / 2, label);
} 
